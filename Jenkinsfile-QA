// Define shared constants for the pipeline
def PIPELINE_AGENT_LABEL    = 'QA'                            // Jenkins agent label
def DOCKER_CYPRESS_IMAGE    = 'cypress/included:13.1.0'       // Docker image with Cypress pre-installed
def DOCKER_MAVEN_IMAGE      = 'maven:3-eclipse-temurin-21'    // Docker image for Maven build
def CICD_LAST_STARTED_STAGE = ''                              // Track the last started stage

pipeline {
  agent {
    label PIPELINE_AGENT_LABEL  // Use the defined agent for the entire pipeline
  }

  environment {
    // Generate a temporary filename to store flag settings as a shell script
    FLAG_SETTINGS_SCRIPT = sh(script: 'mktemp -u -p . tmp.XXXXXX.envsh', returnStdout: true)

    // Define feature flags
    FLAGS = "CYPRESS_LOGIN_NL-DEV,${env.FLAGS ?: ''}"
    TZ = 'Europe/Amsterdam'
  }

  stages {

    stage('Init') {
      steps {
        // Update the last started stage name
        script { CICD_LAST_STARTED_STAGE = STAGE_NAME }

        // Use SSH credentials to pull scripts or data if needed
        sshagent(credentials: ['stikstofje-Github-SSH-key']) {
          sh '''
            # Load flags into the shell environment
            PRODUCT_NAME='GRIP' source "${CICD_SCRIPTS_DIR}"/common/read_job_flags.envsh

            # Save the loaded flags to a shell script file for later sourcing
            declare -p FLAG_SETTINGS > "${FLAG_SETTINGS_SCRIPT}"
          '''
        }
      }
    }

    stage('Cypress') {
      agent {
        docker {
          label PIPELINE_AGENT_LABEL
          image DOCKER_CYPRESS_IMAGE
          reuseNode true

          // Mount CICD script directory into the container, override entrypoint
          args "--entrypoint='' -v '${env.CICD_SCRIPTS_DIR}':'${env.CICD_SCRIPTS_DIR}' -e CICD_SCRIPTS_DIR='${env.CICD_SCRIPTS_DIR}'"
        }
      }

      steps {
        script { CICD_LAST_STARTED_STAGE = STAGE_NAME }
        sh '''#!/usr/bin/env bash
          # Exit on error + print commands
          set -ex

          # Read in flags from file
          source "${FLAG_SETTINGS_SCRIPT}"

          # Change to working directory
          cd source/frontend/

          # Fetch npm modules
          npm ci

          # Determine DEPLOY_WEBHOST related vars - this will have the URL the environment is deployed to
          source "${CICD_SCRIPTS_DIR}"/common/determine_deploy_webhost.envsh

          # Wait on application to start properly
          npx wait-on -l https://"${DEPLOY_WEBHOST}"

           # Wait extra time to ensure the environment is fully ready
          sleep 30m

          # Start Cypress
          CYPRESS_USERNAME="${FLAG_SETTINGS[CYPRESS_LOGIN_USERNAME]}" \
          CYPRESS_PASSWORD="${FLAG_SETTINGS[CYPRESS_LOGIN_PASSWORD]}" \
          CYPRESS_API_ENDPOINT="https://${FLAG_SETTINGS[FAME_PLATFORM_HOST]}" \
          CYPRESS_TEST_PROFILE="${SERVICE_THEME}" \
            cypress run \
              --config baseUrl=https://"${DEPLOY_WEBHOST}" \
              --config-file cypress/cypress.config.ts || true
        '''
      }
    }

    stage('Sonar') {
      agent {
        docker {
          label PIPELINE_AGENT_LABEL
          image DOCKER_MAVEN_IMAGE
          reuseNode true
        }
      }

      steps {
        script { CICD_LAST_STARTED_STAGE = STAGE_NAME }

        // Use SonarQube token from Jenkins credentials
        withCredentials([string(credentialsId: 'SONAR_TOKEN', variable: 'SONAR_TOKEN')]) {
          sh 'mvn -f source/pom.xml clean verify org.sonarsource.scanner.maven:sonar-maven-plugin::sonar -Psonar --no-transfer-progress -Dmaven.test.failure.ignore=true'
        }
      }
    }
  }

  post {
    always {

      // Attempt to parse and archive any JUnit test results
      catchError {
        junit '**/TEST-*.xml,source/frontend/cypress/reports/junit/*.xml'
      }

      // Attempt to parse and archive Cucumber reports generated by Cypress
      catchError {
        cucumber jsonReportDirectory: 'source/frontend/cypress/', fileIncludePattern: '**/*.cucumber.json'
      }

      // Send build notification to Mattermost
      withBuildUser {
        script {
          env.CICD_LAST_STARTED_STAGE = CICD_LAST_STARTED_STAGE

          mattermostSend(
            channel: (env.MATTERMOST_CHANNEL ? "#${env.MATTERMOST_CHANNEL}" : null),
            color: sh(script: """${CICD_SCRIPTS_DIR}/job/notify_mattermost_color.sh "${currentBuild.result}" """, returnStdout: true),
            message: sh(script: """${CICD_SCRIPTS_DIR}/job/notify_mattermost_message.sh "${currentBuild.result}" "${currentBuild.durationString}" QA """, returnStdout: true)
          )
        }
      }
    }
  }
}
